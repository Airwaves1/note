[toc]

# 1.C和C++

## 1.1C++中struct和class的区别
- 相同点：
  - 两者都拥有成员函数、公有和私有成员、构造函数和析构函数。
  - 任何可以使用class的地方都可以使用struct

- 不同点：
  - 两者如果不对成员指定公有或私有，默认是不同的。struct默认是公有的，class默认是私有的。
  - class默认是私有继承，struct默认是公有继承。
- 引申
 C++的struct和C中的struct有很大的不同。C中的struct只是一种数据结构，没有成员函数，没有访问控制，没有继承，没有多态，没有构造函数和析构函数。C++中的struct是一种类，拥有C++中的所有特性。

 ---
# 2.面向对象

## 2.1.讲一讲封装，继承，多态是什么
  - 封装 ：将具体实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性，使类称为一个具有内部数据的自我隐藏能力、功能的封装体。意义：保护或者防止代码在无意之中被破坏，保护类中的成员，不让类中以外的程序直接访问或者修改，只能通过提供的公共接口访问。
  - 继承 ：子类继承父类的特征和行为，复用了基类的全体数据和成员函数，具有从基类复制而来的数据成员和成员函数（基类私有成员可以被继承，但无法被访问），其中构造函数，析构函数，友元函数，静态数据成员，静态成员函数都不能被继承。基类中成员的访问方式只能决定派生类是否能访问它们。增强了代码的耦合性，当父类中的成员变量或者类本身被final关键字修饰时，修饰的类不能被继承，修饰的成员变量不能重写或修改。意义：基类的程序代码可以被派生类使用，提高了软件复用的效率，缩短了软件开发的周期
  - 多态：不同继承类的对象对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使其基类指针呈现不同的表现形式。意义：对存在的代码具有可替代性，对代码具有可扩充性，新增子类不会影响已存在类的各种性质，在程序中体现了灵活多样的操作，提高了使用效率，简化了对应代码的编写和修改过程。

## 2.2.多态的实现原理是什么？以及多态的优点。
实现方式：多态分为动态多态，静态多态
 - 动态多态：动态多态是利用虚函数实现运行时的多态，即在系统编译的时候并不知程序将要调用哪一个函数。虚函数是类的成员函数，存储虚函数指针的表叫做虚函数表，虚函数表是一个存储类成员虚函数的指针，每个指针都指向调用的它的地方，当子类调用虚函数的时候，就会去虚表里找到自己对应的函数指针，从而实现谁调用谁执行的效果。
 - 静态多态：又称为编译时期的多态，即系统编译的时候就确定了程序将要执行哪个函数。通过函数重载来实现的，函数重载是指在同一个类中，函数名相同，参数列表不同的函数，通过函数重载，可以根据传入的参数的不同，调用不同的函数。其中重定义，又叫隐藏，会把基类的函数隐藏掉，不会被调用，而重载会根据传入的参数的不同，调用不同的函数，可以通过作用域解析符来调用基类的函数。

优点：
  -   使程序具有可扩充性，新增子类不会影响已存在类的各种性质，提高了软件复用的效率，缩短了软件开发的周期，对存在的代码具有可替代性，提高了使用效率，简化了对应代码的编写和修改过程。

## 2.3.虚函数是怎么实现的？他存放在内存的哪个区？什么时候生成的？
- 在C++中，虚函数的实现原理基于两个关键的概念：虚函数表和虚函数指针
- 虚函数表：每个虚函数的类都会生成一个虚函数表，其中存储着该类中的所有虚函数的地址。虚函数表是一个由指针构成的数组，每个指针指向一个虚函数的实现代码。
- 虚函数指针：在对象的内存布局中，编译器会添加一个额外的指针，称为虚函数指针或者虚表指针。这个指针指向该对象对应的虚函数表，从而让程序能够在运行时动态地找到对应的虚函数。

总结：当一个基类指针或者引用调用虚函数时，编译器会使用虚表指针来查找该对象对应的虚函数表，并根据函数在虚函数表中的位置来调用正确的虚函数。
虚函数在编译阶段生成，虚函数和普通函数一样存放在代码段，只是它的指针又存放到了虚表之中。

---
# 3.内存、编译

## 3.1引用和指针的区别
==最主要区别 ：== 指针可以指向空值，而引用不可以；指针可以随意更改指向的对象，而引用不可以。指针需要使用*来访问其指向的对象，而引用不需要。
- 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名。
- 指针可以分很多级，引用只有一级。
- 指针可以为空，引用不能为空，在初始化之后不能被改变。
- sizeof指针得到的大小是指针的大小，sizeof引用得到的大小是引用所指向变量的大小。
- 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的是同一个地址。但不是同一个变量，在函数中修改这个指针变量的指向，不会影响实参的指向，而引用可以，因为引用是实参的别名。
- 引用本质是一个指针，同样会占4个字节的内存，指针是具体变量，需要占用存储空间。

## 3.2堆和栈的区别
- 栈：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
- 堆：由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。其操作方式类似于链表。

|  | 栈 | 堆 |
| --- | --- | --- |
管理方式|栈资源由编译器自动管理，无需手工管理。|堆资源由程序员手工管理，需要程序员手工申请和释放。|
内存管理机制|只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。|系统有一个记录空闲内存地址的链表，当程序需要内存时，系统遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。|
空间大小|栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M，在编译的时候就确定好了。| 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址的），堆的大小受限于计算机系统中有效的虚拟内存，（32bit系统下是4G），所以堆的大小远远大于栈的大小。|
碎片问题| 对于栈，它是类似与数据结构中的先进后出的栈，进出一一对应，不会产生内存碎片。| 对于堆，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。|
分配方式| 栈是有动态分配和静态分配，静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。| 堆是动态分配的，没有静态分配，它的动态分配是由程序员手工实现的，也就是我们常说的new/delete。|
分配效率| 栈是系统提供的数据结构，在底层对栈提供支持，分配专门的寄存器存放栈的地址，这样存取速度会快。| 堆是C/C++函数库提供的，它的机制是很复杂的，而且要保证分配的内存是连续的，所以速度会比栈慢。|


## 3.3将引用作为函数参数有哪些好处？
 + 1.使用引用传参，不会创建拷贝，可以提升效率并节省空间，比如我们要传入一个很大的结构体，用引用传参就省去了拷贝这个结构体的开销。
 + 2.在函数中对该变量进行修改，则参数返回后修改依然有效。
 + 3.C++标准不允许复制构造函数传值参数，最好是传引用。复制构造函数A（A other）传入参数是一个A的实例。由于是传值参数，我们把形参复制到实参就会调用复制构造函数，如果允许复制构造函数传值参数，那么就会无限循环调用复制构造函数，直到栈溢出。因此，C++标准不允许复制构造函数传值参数，最好是传引用，把复制构造函数改为A（const A& other），就是把传值参数改为常量引用参数。


 
## 3.4new/delete和malloc/free的 异同
- 相同点：
  都是用于内存的动态申请和释放的。

- 不同点：
    - 1 new/delete是C++的运算符，malloc/free是C的库函数。
    - 2 new 是自动计算需要分配的空间，malloc需要手动计算需要分配的空间。
    - 3 new是类型安全的，malloc不是类型安全的。
    例如：
    ```cpp
    int* p =new float[10]; //编译器会报错
    int* p = (int*)malloc(sizeof(float)*10); //编译器不会报错
    ```
    - 4 new调用名为operator new的函数分配足够空间，然后调用构造函数初始化对象。delete调用析构函数，然后调用operator delete释放空间。malloc/free只是分配和释放空间，不会调用构造函数和析构函数。

    - 5 后者需要库文件支持，前者不需要。new/delete是C++的运算符，不需要库文件支持。malloc/free是C的库函数，需要库文件支持。

    - 6 new 封装了malloc，直接free不会报错，但这只是释放内存空间，不会调用析构函数。

## 3.5.new 和 delete 是如何实现的
- new的实现过程是：首先调用名为operator new的标准库函数，分配足够大的空间为类型化的内存，已保存指定类对象的一个实例。然后调用构造函数初始化对象，最后返回指向新分配并构造后的对象的指针。
- delete的实现过程是：首先调用析构函数，然后调用operator delete释放空间。

## 3.6.strlen和sizeof的区别
- 编译器在编译阶段就计算出了sizeof的结果，而strlen是在运行时计算的。sizeof是一个运算符，strlen是一个函数。

- sizeof计算的是类型的大小，strlen计算的是字符串的长度。

- sizeof的参数可以是数据类型，变量，表达式，strlen的参数只能是字符指针，这个字符指针必须指向以'\0'结尾的字符串，在声明char* 字符串后，编译器会在字符串的末尾自动加上'\0'。



## 3.7.野指针和悬空指针的概念
- 野指针，未被初始化的指针
因此为了防止出错。对于指针初始化时，都是赋值为nullpter，这样在使用时，编译器就会直接报错，产生非法内存访问

- 悬空指针
 悬空指针最初指向的内存已经被释放了的一种指针。悬空指针是一种危险的指针，因为它指向的内存可能已经被分配给其他变量使用了，所以使用悬空指针会导致程序崩溃。
 ```cpp
 int main(void)
 {
    int* p1 = nullpter;
    int* p2 = new int;
    p1 = p2;
    delete p2;
 }
```
此时，p1和p2都是悬空指针，因为p2指向的内存已经被释放了，p1指向的内存已经被释放了。
继续使用这两个指针，行为不可以预测。需要设置为nullptr    `p1 = nullptr; p2 = nullptr;`
这样在使用时，编译器就会直接报错，产生非法内存访问

避免野指针比较简单，但悬空指针比较麻烦，因为悬空指针是在程序运行时才会出现的，而野指针是在编译时就可以发现的。
因此，避免悬空指针的方法是在释放指针后，将指针设置为nullptr。
C++11中引入了智能指针，可以自动释放内存，避免悬空指针的出现。C++智能指针的本质就是避免悬空指针的产生。
- 总结：
   -野指针：是指针变量未及时初始化，解决方法是在定义指针变量时就初始化为nullptr。
   -悬空指针：是指针变量指向的内存已经被释放，解决方法是在释放指针后，将指针设置为nullptr。


   
## 3.8.define宏定义和const的区别
- 编译阶段
  - define是在预处理阶段进行替换，const是在编译阶段、运行的时候起作用。
- 安全性
  -define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住。
  -const常量有数据类型，编译器可以对其进行类型检查
- 内存占用
  - define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行的时候只有一份备份，且可以执行常量折叠，能将复杂的表达式计算出结果然后放入常量表。
  - 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。
  - 宏不检查类型，const会检查类型。
  - 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间

## 3.9.智能指针的本质是什么，他们的实现原理是什么？
智能指针的本质是一个封装了一个原始C++指针的类模板，为了确保动态内存的安全性而产生的。实现原理是通过一个对象存储需要被自动释放的资源，然后依靠对象的析构函数来释放资源。

---
# 4.关键字库函数

## 4.1.final标识符的作用是什么？
final关键字可以修饰类，成员函数，虚函数，变量。final修饰类，表示该类不能被继承。修饰成员函数，表示该函数不能被重写。修饰虚函数，表示该函数不能被重写。修饰变量，表示该变量不能被修改。
---
# 5.STL相关

---
# 6.语言特性

---
# 7.操作系统

---
# 8.数据结构算法

---
# 9.网络

---
# 10.数据库



















---






















